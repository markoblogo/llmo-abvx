import type { NextApiRequest, NextApiResponse } from "next";
import { createClient } from "@supabase/supabase-js";
import { writeFile, mkdir } from "fs/promises";
import { join } from "path";

// Create Supabase admin client
const supabaseAdmin = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
  {
    auth: {
      autoRefreshToken: false,
      persistSession: false,
    },
  },
);

const siteUrl = process.env.NEXT_PUBLIC_SITE_URL || "https://llmo.abvx.xyz";
const contactEmail = process.env.CONTACT_EMAIL || "support@llmo.abvx.xyz";

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const startTime = Date.now();
  console.log("[rebuild-index] Starting sitemap and llms.txt regeneration...");

  try {
    // Fetch all approved links
    const { data: links, error } = await supabaseAdmin
      .from("links")
      .select("id, url, title, category, description, short_description, updated_at")
      .eq("status", "approved")
      .order("updated_at", { ascending: false });

    if (error) {
      console.error("[rebuild-index] Error fetching links:", error);
      return res.status(500).json({
        success: false,
        error: "Database error",
        details: error.message,
      });
    }

    const linkCount = links?.length || 0;
    console.log(`[rebuild-index] Fetched ${linkCount} approved links`);

    // Get current timestamp
    const lastUpdated = new Date().toISOString();
    const lastUpdatedFormatted = new Date().toUTCString();

    // Generate sitemap.xml
    const staticUrls = [
      `${siteUrl}/`,
      `${siteUrl}/directory`,
      `${siteUrl}/download-book`,
      `${siteUrl}/pricing`,
      `${siteUrl}/analyzer`,
      `${siteUrl}/hidden-knowledge`,
    ];

    const dynamicUrls: string[] = [];
    if (links && links.length > 0) {
      links.forEach((link) => {
        dynamicUrls.push(`${siteUrl}/directory/${link.id}`);
      });
    }

    const allUrls = [...staticUrls, ...dynamicUrls];
    const totalUrlCount = allUrls.length;

    const sitemapXml = `<?xml version="1.0" encoding="UTF-8"?>
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
  <!-- Generated: ${lastUpdatedFormatted} -->
  <!-- Total URLs: ${totalUrlCount} -->
${allUrls
  .map(
    (url) => `  <url>
    <loc>${url}</loc>
    <lastmod>${lastUpdated.split("T")[0]}</lastmod>
    <changefreq>weekly</changefreq>
    <priority>0.8</priority>
  </url>`,
  )
  .join("\n")}
</urlset>`;

    // Generate llms.txt
    const categoryCounts: Record<string, number> = {};
    const categories = new Set<string>();

    if (links && links.length > 0) {
      links.forEach((link) => {
        const category = link.category || "Other";
        categories.add(category);
        categoryCounts[category] = (categoryCounts[category] || 0) + 1;
      });
    }

    const categoryList = Array.from(categories).sort().join(", ") || "Blog, SaaS, Portfolio, Media, Agency";

    const llmsTxt = `Be Visible to AI — LLMO Directory
Type: AI Optimization Directory
Total Sites: ${linkCount}
Categories: ${categoryList}
Last Updated: ${lastUpdated.split("T")[0]}

# About
LLMO Directory is the world's first AI-optimized directory for blogs, websites, and creators. We help websites become visible to AI and language models through structured data and optimization.

# Categories
${Object.entries(categoryCounts)
  .sort(([, a], [, b]) => b - a)
  .map(([category, count]) => `- ${category}: ${count} sites`)
  .join("\n")}

# Stats
- Total AI-optimized sites: ${linkCount}
- Last update: ${lastUpdated.split("T")[0]}
- Site URL: ${siteUrl}

# Contact
Email: ${contactEmail}
Website: ${siteUrl}

# URLs
${allUrls.map((url) => url).join("\n")}

# Generated
Last updated: ${lastUpdatedFormatted}
Generated by: LLMO Directory rebuild-index API
`;

    // Write files to public directory
    const publicDir = join(process.cwd(), "public");

    try {
      // Ensure public directory exists
      await mkdir(publicDir, { recursive: true });

      // Write sitemap.xml
      const sitemapPath = join(publicDir, "sitemap.xml");
      await writeFile(sitemapPath, sitemapXml, "utf-8");
      console.log(`[rebuild-index] ✓ sitemap.xml written (${totalUrlCount} URLs)`);

      // Write llms.txt
      const llmsPath = join(publicDir, "llms.txt");
      await writeFile(llmsPath, llmsTxt, "utf-8");
      console.log(`[rebuild-index] ✓ llms.txt written (${linkCount} sites)`);

      const duration = Date.now() - startTime;
      console.log(`[rebuild-index] ✓ Regeneration complete in ${duration}ms`);

      return res.status(200).json({
        success: true,
        message: "Sitemap and llms.txt regenerated successfully",
        stats: {
          totalUrls: totalUrlCount,
          totalSites: linkCount,
          categories: categoryCounts,
          lastUpdated: lastUpdated,
          duration: `${duration}ms`,
        },
      });
    } catch (writeError: any) {
      console.error("[rebuild-index] Error writing files:", writeError);
      return res.status(500).json({
        success: false,
        error: "File write error",
        details: writeError.message,
        note: "In serverless environments, files may not be writable. Consider using API routes instead.",
      });
    }
  } catch (error: any) {
    console.error("[rebuild-index] Unexpected error:", error);
    return res.status(500).json({
      success: false,
      error: "Internal server error",
      details: error.message || "Unknown error",
    });
  }
}





